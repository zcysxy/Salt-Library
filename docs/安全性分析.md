# 安全性分析

[[Report]]

---

最后我们想对本应用的安全性再做一些强调. 我们不敢说本应用的安全系数极高, 但我们确实在所有的设计环节都认真考虑了安全性的问题, 并将其作为重中之重的因素. 现在我们列出应用设计中所有提高安全性的措施

* 重视数据库端
    * 这点我们已经提及多次, 通过让数据的验证与修改插入等过程由数据库内部的函数, 过程, 和触发器来实现, 数据库的安全性, 稳定性, 和连续性得到了更好的保障, 有更强的鲁棒性.
* 用户管理系统
    * 所有数据中用户的数据需要得到最好的保障, 我们的**两层用户管理系统**就是基于此设计的.
    * 用户自行注册的是应用用户, 而非数据库用户, 因此除馆长外其他角色不具有删除用户的权限.
    * 书友密码以 **MD5** 方法加密后储存.
    * 书友 ID 等信息临时储存在应用会话 (session) 和 `current_user` 中, 并在书友登出后使用 `logout_user()` 和 `session.clear()` 清空, 保证数据不会被泄露.
    * 用户只有完成验证登录应用后, 才可以以相应角色连接数据库.
* 两层授权
    * 首先我们仔细设计了[[SQL 授权]], 使得非馆长角色的权限集中为 `SELECT` 和 `INSERT`, 较少修改和删除数据的权限, 即使有, 也是被数据库内部的**储存过程**利用, 保证了数据的安全性.
    * 除了[[SQL 授权]]外, 我们还在应用层面实现了[[角色管理]], 通过 `@role_required(*roles)` 函数装饰器实现了不同功能的权限限制.
    * 应用层面我们还广泛使用谓词 `WHERE id = current_user.id`, 将权限从以**表**为单位进一步缩限为以**一条数据**为单位. 即一些信息用户只能访问与自己相关的, 这进一步提高了数据的安全性.
* [[数据库连接]]
    * [[一命令一连接]]的设计以部分效率为代价显著地提高了系统的安全性. 它使得数据库连接**原子化**, 将数据损失或发生错误的可能性和严重性降到了最低.
    * `Connect` 中所有方法均包裹在 `try...except` 语句中, 并在任何错误发生时回滚操作, 关闭接口, 并返回错误信息, 这样数据错误几乎不可能发生了.
