# App User Vs.  Database User

[[Report]]

---

用一句话概括: 本实验项目将数据库角色和应用用户分开了, 而不同于原题, 数据库用户与应用用户是一致的.

该**两层用户管理系统**具体的流程与实现请见系统设计中的[[书友的注册与登录]]部分, 这里要说明的是我们为何选择这种设计.

首先, 这种设计是应用性质的要求. 本实验项目跟原题的一个本质区别是, 原系统的目标就是**操作数据库**, 而本实验项目是将数据库作为应用的一部分, 为用户在应用中进行各种操作提供支持. 这意味着本实验项目中的应用用户和数据库用户有着**概念**上的不同. 而各种实际情况和需求又要求这种概念上的不同转化为实际的分隔. 比如我们假设这个应用面对的是大量用户, 那么同时保留数据库用户信息和 *miners* 表中的书友信息会增加储存成本和造成信息冗余.

另外, 因为我们采用的是**自注册**方式, 若注册的是数据库用户, 会产生很大的安全隐患. 一是我们要赋予游客/public 创建用户的权限 `CREATEROLE`, 而且这个权限同时包括了 `ALTER` 和 `DROP` roles, 这怎么看都是不合理的; 二是掌握了数据库密码, 用户有可能越过应用界面 (越过**第二重授权**) 直接操纵数据库.

综上, 我们选择让用户自行注册应用的账号, 然后所有用户登录后统一以 `miner` 书友这一**角色**连接数据库. 因此不管应用有多少用户, 数据库用户/角色只有三个.

/@ 补充

实际上, 馆长这个角色就是一个数据库用户 `curator`, 对于他我们没有用到 Flask-Login 的功能, 他在登录后应用也是直接利用他输入的密码连接数据库的. 利用同样的办法, 我们完全可以跳过应用层直接注册和登陆数据库用户. 因此可以说本实验项目是**包含**了原题的方式的, 而在其之上实现了更复杂, 考虑的更细致的, 更符合实际的用户管理系统.

@/
